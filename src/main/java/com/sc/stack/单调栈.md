# 单调栈

[739.每日温度](https://leetcode.cn/problems/daily-temperatures/description/)

[496.下一个更大元素I](https://leetcode.cn/problems/next-greater-element-i/)

[503.下一个更大元素II](https://leetcode.cn/problems/next-greater-element-ii/)

[42.接雨水](https://leetcode.cn/problems/trapping-rain-water/)

[84.柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

- **适应场景**：求数组中元素的下一个更大或者更小值
- **栈中元素**：栈中存储的是已遍历元素中**暂未找到**下个更大或更小值元素的**下标**
- **遍历过程**：当遍历到的元素大于或小于栈顶对应的元素时，当前遍历到的元素即为栈顶元素的下一个更大或更小值，此时弹出栈顶元素，记录栈顶元素的下一个更大或更小值。

## 1.从左往右求下一个更大值

栈中元素的顺序从**栈顶到栈底**是**单调递增**的

```java
int[] nums = {2, 1, 4, 6, 5};
Stack<Integer> stack = new Stack<>();
for (int i = 0; i < nums.length; i++) {
    // 当前元素大于栈顶元素，说明找到下一个比栈顶元素大的值
    while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {
        // 弹出栈顶元素，因为找到了下一个比它大的元素，即num[i]
        int index = stack.pop();
        // 此时栈顶可能为空
        if (stack.isEmpty()) break;
        // 此时的栈顶元素为index对应元素左边的第一个比index对应元素大的值的下标
        int leftMaxIndex = stack.peek();
        // 当前值为index对应元素右边第一个比index对应元素大的值的下标
        int rightMaxIndex = i;
    }
    stack.push(i);
}
```

## 2.从左往右求下一个更小值

栈中元素的顺序从**栈顶到栈底**是**单调递减**的

```java
int[] nums = {2, 1, 4, 6, 5};
Stack<Integer> stack = new Stack<>();
for (int i = 0; i < nums.length; i++) {
    // 当前元素大于栈顶元素，说明找到下一个比栈顶元素小的值
    while (!stack.isEmpty() && nums[i] < nums[stack.peek()]) {
        // 弹出栈顶元素，因为找到了下一个比它小的元素，即num[i]
        int index = stack.pop();
        // 此时栈顶可能为空
        if (stack.isEmpty()) break;
        // 此时的栈顶元素为index对应元素左边的第一个比index对应元素小的值的下标
        int leftMinIndex = stack.peek();
        // 当前值为index对应元素右边第一个比index对应元素小的值的下标
        int rightMinIndex = i;
    }
    stack.push(i);
}
```

## 3.从右到左求下个更大或更小值

将数组倒序遍历即可