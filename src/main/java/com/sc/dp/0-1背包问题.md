# 0-1背包问题

给定：背包容量为`n`，物品重量数组：`weights`，物品价值数组：`values`，规定每个物品只能**挑选一次**。

```java
int n = 10;
int[] weights = {1, 2, 2, 5};
int[] values = {2, 4, 5, 8};
```

## 1.求背包能够装下的最大价值

[416.分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/description/)

[1049.最后一块石头的重量II](https://leetcode.cn/problems/last-stone-weight-ii/description/)

- **定义dp数组**

  容量为i的背包所能装下的最大物品价值为dp[i]

  ```java
  int[] dp = new int[n + 1];
  ```

- **dp数组初始化**

  ```java
  dp[0] = 0;
  ```

- **确定递推关系**

  **dp[j - weights[i]] + values[i]**： 表示容量为j的背包空出物品i的重量weights[i]后所能装下的最大价值加上物品i的价值（即放入物品i后的最大价值）
  
  **dp[j]**：不放物品i的最大价值

  所以dp[j]为二者取最大值：
  
  ```java
  dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
  ```

- **确定遍历顺序**

  先遍历物品再遍历背包容量（**不能颠倒**）

  遍历背包时要**倒序遍历**，如果正序遍历，一个物品会被添加多次

  ```java
  for (int i = 0; i < weights.length; i++) {
      for (int j = n; j >= weights[i]; j--) {
          dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
      }
  }
  ```

完整代码：

```java
int n = 10;
int[] weights = new int[]{1, 2, 2, 5};
int[] values = new int[]{2, 4, 5, 8};
int[] dp = new int[n + 1];
dp[0] = 0;
for (int i = 0; i < weights.length; i++) {
    for (int j = n; j >= weights[i]; j--) {
        dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
    }
}
return dp[n];
```

## 2.求装满背包有多少种方法

[494.目标和](https://leetcode.cn/problems/target-sum/description/)

- **定义dp数组**

  装满容量为i的背包有dp[i]种方法

  ```java
  int[] dp = new int[n + 1];
  ```

- **dp数组初始化**

  装满容量为0的背包有1种方法，即不放物品

  ```java
  dp[0] = 1;
  ```

- **确定递推关系**

  ```java
  dp[j] += dp[j - weights[i]];
  ```

- **确定遍历顺序**

  先遍历物品再遍历背包容量（**不能颠倒**）

  遍历背包时要**倒序遍历**，如果正序遍历，一个物品会被添加多次

  ```java
  for (int i = 0; i < weights.length; i++) {
      for (int j = n; j >= weights[i]; j--) {
          dp[j] += dp[j - weights[i]];
      }
  }
  ```

完整代码：

```java
int n = 10;
int[] weights = new int[]{1, 2, 2, 5};
int[] dp = new int[n + 1];
dp[0] = 0;
for (int i = 0; i < weights.length; i++) {
    for (int j = n; j >= weights[i]; j--) {
        dp[j] += dp[j - weights[i]];
    }
}
```

## 3.求装满背包的最多物品个数

[474.一和零](https://leetcode.cn/problems/ones-and-zeroes/description/)

- **定义dp数组**

  装满容量为i的背包的最多物品个数为dp[i]

  ```java
  int[] dp = new int[n + 1];
  ```

- **dp数组初始化**

  ```java
  dp[0] = 0;
  ```

- **确定递推关系**

  **dp[j - weights[i]] + 1**： 表示容量为j的背包空出物品i的重量weights[i]后所能装下的最多物品个数加上1（即放入物品i后的最多物品个数）

  **dp[j]**：不放物品i的最多物品个数

  ```java
  dp[j] = Math.max(dp[j], dp[j - weights[i]] + 1);
  ```

- **确定遍历顺序**

  先遍历物品再遍历背包容量（**不能颠倒**）

  遍历背包时要**倒序遍历**，如果正序遍历，一个物品会被添加多次

  ```java
  for (int i = 0; i < weights.length; i++) {
      for (int j = n; j >= weights[i]; j--) {
          dp[j] = Math.max(dp[j], dp[j - weights[i]] + 1);
      }
  }
  ```

完整代码：

```java
int n = 10;
int[] weights = new int[]{1, 2, 2, 5};
int[] dp = new int[n + 1];
dp[0] = 0;
for (int i = 0; i < weights.length; i++) {
    for (int j = n; j >= weights[i]; j--) {
        dp[j] = Math.max(dp[j], dp[j - weights[i]] + 1);
    }
}
return dp[n];
```
