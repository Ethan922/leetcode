# 完全背包问题

给定：背包容量为`n`，物品重量数组：`weights`，物品价值数组：`values`，每个物品的数量为无限个。

```java
int n = 10;
int[] weights = new int[]{1, 2, 2, 5};
int[] values = new int[]{2, 4, 5, 8};
```

## 1.求背包能够装下的最大价值

- **定义dp数组**

  容量为i的背包所能装下的最大物品价值为dp[i]

  ```java
  int[] dp = new int[n + 1];
  ```

- **dp数组初始化**

  ```java
  dp[0] = 0;
  ```

- **确定递推关系**

  **dp[j - weights[i]] + values[i]**： 表示容量为j的背包空出物品i的重量weights[i]后所能装下的最大价值加上物品i的价值（即放入物品i后的最大价值）

  **dp[j]**：不放物品i的最大价值

  所以dp[j]为二者取最大值：

  ```java
  dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
  ```

- **确定遍历顺序**

  先遍历物品再遍历背包容量（**可以颠倒**）

  遍历背包时要**正序遍历**，一个物品被添加多次

  ```java
  for (int i = 0; i < weights.length; i++) {
      for (int j = weights[i]; j <= n ; j++) {
          dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
      }
  }
  ```

完整代码：

```java
int n = 10;
int[] weights = new int[]{1, 2, 2, 5};
int[] values = new int[]{2, 4, 5, 8};
int[] dp = new int[n + 1];
dp[0] = 0;
for (int i = 0; i < weights.length; i++) {
    for (int j = weights[i]; j <= n ; j++) {
        dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
    }
}
return dp[n];
```

## 2.求装满背包有多少种方法

求组合数：[518.零钱兑换](https://leetcode.cn/problems/coin-change-ii/)

求排列数：[377.组合总和IV](https://leetcode.cn/problems/combination-sum-iv/description/)

- **定义dp数组**

  装满容量为i的背包有dp[i]种方法

  ```java
  int[] dp = new int[n + 1];
  ```

- **dp数组初始化**

  装满容量为0的背包有1种方法，即不放物品

  ```java
  dp[0] = 1;
  ```

- **确定递推关系**

  ```java
  dp[j] += dp[j - weights[i]];
  ```

- **确定遍历顺序**

  **求组合数**：先遍历物品再遍历背包容量

  ```java
  // 求组合数
  for (int i = 0; i < weights.length; i++) {
      for (int j = weights[i]; j <= n; j++) {
          dp[j] += dp[j - weights[i]];
      }
  }
  ```

  **求排列数**：先遍历背包容量再遍历物品

  ```java
  // 求排列数
  for (int j = 0; j <= n; j++) {
      for (int i = 0; i < weights.length; i++) {
          if (j >= weights[i]) dp[j] += dp[j - weights[i]];
      }
  }
  ```

  遍历背包时要**正序遍历**，一个物品可以被添加多次


完整代码：

```java
int n = 10;
int[] weights = new int[]{1, 2, 2, 5};
int[] dp = new int[n + 1];
dp[0] = 1;
// 求组合数
for (int i = 0; i < weights.length; i++) {
    for (int j = weights[i]; j <= n; j++) {
        dp[j] += dp[j - weights[i]];
    }
}

// 求排列数
for (int j = 0; j <= n; j++) {
    for (int i = 0; i < weights.length; i++) {
        if (j >= weights[i]) dp[j] += dp[j - weights[i]];
    }
}
```

## 3.求装满背包的最多物品个数

- **定义dp数组**

  装满容量为i的背包的最多物品个数为dp[i]

  ```java
  int[] dp = new int[n + 1];
  ```

- **dp数组初始化**

  ```java
  dp[0] = 0;
  ```

- **确定递推关系**

  **dp[j - weights[i]] + 1**： 表示容量为j的背包空出物品i的重量weights[i]后所能装下的最多物品个数加上1（即放入物品i后的最大物品个数）

  **dp[j]**：不放物品i的最多物品个数

  二者取最大值：

  ```java
  dp[j] = Math.max(dp[j], dp[j - weights[i]] + 1);
  ```

- **确定遍历顺序**

  先遍历物品再遍历背包容量（**可以颠倒**）

  遍历背包时要**正序遍历**，一个物品可以被添加多次

  ```java
  for (int i = 0; i < weights.length; i++) {
      for (int j = weights[i]; j <= n; j++) {
          dp[j] = Math.max(dp[j], dp[j - weights[i]] + 1);
      }
  }
  ```

完整代码：

```java
int n = 10;
int[] weights = new int[]{1, 2, 2, 5};
int[] dp = new int[n + 1];
dp[0] = 0;
for (int i = 0; i < weights.length; i++) {
    for (int j = weights[i]; j <= n; j++) {
        dp[j] = Math.max(dp[j], dp[j - weights[i]] + 1);
    }
}
return dp[n];
```

## 4.求装满背包的最少物品个数

[322.零钱兑换](https://leetcode.cn/problems/coin-change/description/)

[279.完全平方数](https://leetcode.cn/problems/perfect-squares/description/)

- **定义dp数组**

  装满容量为i的背包的最少物品个数为dp[i]

  ```java
  int[] dp = new int[n + 1];
  ```

- **dp数组初始化**

  ```java
  // 其他元素初始化为int最大值
  Arrays.fill(dp,Integer.MAX_VALUE);
  // 装满容量为0的背包最少物品个数为0
  dp[0] = 0;
  ```

- **确定递推关系**

  **dp[j - weights[i]] + 1**： 表示容量为j的背包空出物品i的重量weights[i]后所能装下的最少物品个数加上1（即放入物品i后的最少物品个数）

  **dp[j]**：不放物品i的最少物品个数

  二者取最小值：

  ```java
  dp[j] = Math.min(dp[j], dp[j - weights[i]] + 1);
  ```

- **确定遍历顺序**

  先遍历物品再遍历背包容量（**可以颠倒，不关心物品的顺序，即不关心是排列还是组合**）

  遍历背包时要**正序遍历**，一个物品可以被添加多次

  ```java
  for (int i = 0; i < weights.length; i++) {
      for (int j = weights[i]; j <= n; j++) {
          dp[j] = Math.min(dp[j], dp[j - weights[i]] + 1);
      }
  }
  ```

完整代码：

```java
int n = 10;
int[] weights = new int[]{1, 2, 2, 5};
int[] dp = new int[n + 1];
dp[0] = 0;
for (int i = 0; i < weights.length; i++) {
    for (int j = weights[i]; j <= n; j++) {
        dp[j] = Math.min(dp[j], dp[j - weights[i]] + 1);
    }
}
return dp[n];
```

